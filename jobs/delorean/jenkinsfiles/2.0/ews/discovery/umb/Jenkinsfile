#!groovy

@Library('delorean-pipeline-library') _

import org.integr8ly.GitHubUtils
import org.kohsuke.github.GitHub
import org.kohsuke.github.GHPullRequest
import org.kohsuke.github.GitHubBuilder

def ghUtils = new GitHubUtils()

def createJiraQuery(labels) {
  String query = "project = INTLY AND status = Open"

  for (i = 0; i < labels.size(); i++) {
    def label = labels[i].replaceAll('"', "'")
    query = "${query} AND labels=${label}"
  }

  return query
}

String[] jiraLabelsFor(String productName, String tag, def labels = []) {
    def defaultLabels = [
            /"unplanned"/,
            /"${productName}"/
    ]
    if('master' != tag) {
        labels << /"${tag}"/
    }
    return labels + defaultLabels
}

def createJiraBody(summary, description, gitPrUrl, labels) {
  return """{
      "fields": {
          "project": {
              "id": "12321620",
              "key": "INTLY",
              "name": "Integreatly"
          },
          "summary": "${summary}",
          "description": "${description}",
          "labels": ${labels},
          "issuetype": {
              "name": "Task"
          },
          "priority": {
              "id": "3",
              "name": "Major"
          },
          "customfield_12310220": "${gitPrUrl}"
      }
  }"""
}

pipeline {
    agent any

    parameters {
        // https://datagrepper.engineering.redhat.com/id?id=ID:messaging-devops-broker02.web.prod.ext.phx2.redhat.com-44775-1580379079663-8:893046:0:0:1&is_raw=true&size=extra-large
        string defaultValue: '', description: 'This will be populated by the CI trigger', name: 'CI_MESSAGE', trim: true
        string defaultValue: '', description: 'The name of the product', name: 'productName'
        string defaultValue: '', description: 'The name of the product', name: 'productOperator'
        string defaultValue: 'delorean-ews', description: 'The base branch for the <product>-next branch', name: 'sourceBranch'
        string defaultValue: 'cloud-services-delorean@redhat.com', description: 'An email address which recieves a mail generated by the pipeline', name: 'mailTo'
        booleanParam defaultValue: false, description: '[OPTIONAL] Dry run, disables steps which impact external systems!', name: 'dryRun'
    }

    environment {
        productBranch = "${productName}-next"
        githubUserPassCredentialsID = 'githubjenkins'
        jiraCredentials = 'integreatly-jira-bot'
        jiraUrl = "https://issues.redhat.com"
        jiraRestApiUrl = "https://issues.redhat.com/rest/api/2"
    }
    stages {
        stage('Process UMB Message') {
            steps {
                script {
                    sh "echo \"Process UMB Message\""
                    final Map msg = readJSON text: CI_MESSAGE
                    image = msg.info.extra.image.index.pull[1]
                    tag = msg.info.extra.image.index.tags[0]
                    sh "echo Image to process: ${image}"
                }
            }
        }

        stage('Clone Operator Repo') {
            steps {
                cleanWs()
                git branch: '${sourceBranch}', url: 'https://github.com/integr8ly/integreatly-operator'
            }
        }

        stage("Ensure Product Branch") {
            steps {
                withCredentials([usernamePassword(credentialsId: 'githubjenkins', passwordVariable: 'gitPassword', usernameVariable: 'gitUsername')]) {
                    sh("""
                        git config --global user.name 'Automatron'
                        git config --global user.email 'github.eng@feedhenry.com'
                        git config --global credential.username ${gitUsername}
                        git config --global credential.helper "!echo password=${gitPassword}; echo"
                       """)
                }
                script {
                    def checkout = sh(script: 'git checkout ${productBranch}', returnStatus: true)
                    if (checkout) {
                        sh("""
                            git checkout -B ${productBranch}
                           """)
                    }
                    sh 'git rebase ${sourceBranch}'
                }
            }
        }

        stage('Extract Manifests') {
            steps {
                script {
                    gitCommitWhenChanges("Added New image Manifests") { msgs ->
                        sh "scripts/process-image-manifests ${image} ${productName} ${productOperator}"
                        sh "git add ."
                    }
                }
            }
        }

        stage('Process Manifest Images') {
            steps {
                gitCommitWhenChanges("Updated image_mirror_mapping") { msgs ->
                    echo "Process Manifest Images - generate image_mirror_mapping files and update CSV with new images tags"
                    sh "scripts/process-csv-images ${productName}"
                    sh "git add ."
                }
            }
        }

        stage('Mirror Images') {
            steps {
                script {
                    if (params.dryRun) {
                        println "[DRYRUN] If there are image mappings in any image_mirror_mapping files inside the manifest directory they would be mapped"
                    } else {
                        withCredentials([usernamePassword(credentialsId: "quay-integreatly_delorean", usernameVariable: "USERNAME", passwordVariable: "PASSWORD")]) {
                            sh "docker login -u=\"${USERNAME}\" -p=\"${PASSWORD}\" quay.io"
                            sh "scripts/mirror-images.sh"
                        }
                    }
                }
            }
        }

        stage('Push Branch') {
            steps {
                script {
                    int commmitCount = sh(returnStdout: true, script: "git log origin/${sourceBranch}..${productBranch} --pretty=o | wc -l").trim() as int
                    def existingBranchCommitHash = sh(returnStdout: true, script: "git ls-remote origin refs/heads/${productBranch} | cut -f 1").trim()

                    boolean doPush = false

                    if (productName != 'master') {
                        if (productBranch != 'master') {
                            if (existingBranchCommitHash) {
                                doPush = true
                            } else {
                                doPush = commmitCount > 0
                            }
                        }
                    }
                    echo "doPush = ${doPush}"
                    if (doPush) {
                        gitPushBranch(productBranch, true)
                    } else {
                        echo "[INFO] Branch push criteria not met for ${productBranch}"
                    }
                }
            }
        }

        stage('Create Pull Request') {
            steps {
                script {
                    String title = "[WIP] ${productName} update"
                    String body = "Created automatically by jenkins"
                    String[] defaultPRLabels = ["do-not-merge/work-in-progress"]
                    if (params.dryRun) {
                        println "Finds an open pull request with the base branch '${sourceBranch}'. If this does not exist, it creates a new pull request with the following details:\ntitle:'${title}',\nbody '${body}',\nlabels:${defaultPRLabels}"
                        prUrl = "https://github.com/example-pr-url"
                    } else {
                        println("Creating PR for ${productName}")
                        withCredentials([usernamePassword(
                            credentialsId: githubUserPassCredentialsID,
                            passwordVariable: 'GITHUB_PASSWORD',
                            usernameVariable: 'GITHUB_USERNAME')]) {
                            final GitHub gitHub = new GitHubBuilder()
                                    .withOAuthToken(env.GITHUB_PASSWORD, env.GITHUB_USERNAME)
                                    .build()
                            GHPullRequest pr = ghUtils.ghFindOrCreatePullRequest(gitHub.getRepository("integr8ly/integreatly-operator"), "integr8ly:${productBranch}", "${sourceBranch}", title, body, defaultPRLabels)
                            prUrl = pr.getHtmlUrl()
                            println "Component Update PR = ${prUrl}"
                        }
                    }
                }
            }
        }

        stage('Create Jira') {
            steps {
                script {
                    if (params.dryRun) {
                        println "[DRYRUN] A JIRA ticket would be created"
                    } else {
                      String[] labels = jiraLabelsFor("${productName}", "${tag}", [/"product-update"/])
                      String summary = "Update of ${productName} available"
                      String description = "Update of ${productName} is availabe to go back to branch ${sourceBranch}"
                      String query = createJiraQuery(labels)
                      def body = createJiraBody(summary, description, "${prUrl}", labels)
                      def jiraID = jiraCreateIssue("${jiraCredentials}", "${jiraRestApiUrl}", query, body)
                      println "[INFO] JIRA issue: ${jiraUrl}/browse/${jiraID}"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                final Map msg = readJSON text: CI_MESSAGE
                mail(
                        subject: "New build of ${msg.info.name} created in Brew",
                        to: mailTo,
                        body: [
                                "A brew build was created for ${msg.info.name}",
                                "image_url: ${msg.info.extra.image.index.pull[1]}",
                                "product_name: ${msg.info.name}",
                                "jenkins_job: ${env.BUILD_URL}"
                        ].join('\n')
                )
            }
        }
    }
}
