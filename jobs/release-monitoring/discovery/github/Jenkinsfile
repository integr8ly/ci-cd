#!groovy

//Helper methods, should eventually be moved tio a shared library

//remote repository checkout
def checkoutGitRepo(gitUrl, gitRef, credentialsID) {
    checkout([$class: 'GitSCM', branches: [[name: gitRef]],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            submoduleCfg: [],
            userRemoteConfigs: [[credentialsId: credentialsID, url: gitUrl]]])
}

//https://github.com/feedhenry/fh-pipeline-library/blob/master/vars/gitCreateAndCheckoutBranch.groovy
def gitCreateAndCheckoutBranch(branchName, pushOnCreate = false) {
    String remoteBranchCommit = sh(returnStdout: true, script: "git ls-remote origin refs/heads/${branchName} | cut -f 1").trim()

    if (remoteBranchCommit) {
        sh "git checkout ${branchName}"
    } else {
        sh "git checkout -b ${branchName}"
        if (pushOnCreate) {
            if (params.dryRun) {
                String gitRepoUrl = sh(returnStdout: true, script: 'git config --get remote.origin.url').trim()
                print "Would push ${branchName} to ${gitRepoUrl}"
            } else {
                sh "git push origin ${branchName}"
            }
        }
    }
}

String gitRepoIsDirty(untrackedFiles = 'no') {
    return sh(
            returnStdout: true,
            script: "git status --porcelain --untracked-files=${untrackedFiles}"
    )?.trim()
}

//https://github.com/feedhenry/fh-pipeline-library/blob/master/vars/gitCreateAndCheckoutBranch.groovy
boolean gitCommitWhenChanges(commitMsgTitle, body) {
    def changes = []
    def msgs = []
    body(msgs)
    msgs = msgs - null - ""
    if (gitRepoIsDirty()) {
        changes = [commitMsgTitle]
        changes << msgs.join('\n')
        changes = changes.join('\n\n')
        sh "git commit -a -m \"${changes}\""
        return true
    }
    return false
}

//Fetch data from git with credentials
def gitFetch(url, gitTokenId) {
    def response = null
    def data = null

    withCredentials([string(credentialsId: gitTokenId, variable: 'gitToken')]) {
        def headers = [
                ["name": "Authorization", "value": "token ${env.gitToken}"]
        ]

        response = httpRequest customHeaders: headers, url: url
        data = readJSON text: response.content
    }

    return [response.status, data]
}

//Gets the latest release by git tags
def getLatestReleaseByTag(gitOrg, gitRepo, gitTokenId, productName, gaReleaseTagRef) {
    def latestRelease = ""
    def url = "https://api.github.com/repos/${gitOrg}/${gitRepo}/git/refs/tags"

    def (code, releases) = gitFetch(url, gitTokenId)
    if (code != 200) {
      error "[ERROR] Failed to retrieve tags for:${productName}. The :${gitRepo} repository does not have any tags available"
    }

    // Retrieve GA releases only
    releases = releases.findAll { release -> release.ref.contains(gaReleaseTagRef) }
    latestRelease = releases.last().ref
    latestRelease = latestRelease.minus("refs/tags/")

    return latestRelease
}

//Gets the latest release by git releases
def getLatestReleaseByRelease(gitOrg, gitRepo, gitTokenId, productName) {
    def url = "https://api.github.com/repos/${gitOrg}/${gitRepo}/releases/latest"

    def (code, release) = gitFetch(url, gitTokenId)
    if (code != 200) {
        error "[ERROR] Failed to retrieve latest release for:${productName}. The :${gitRepo} repository does not have any releases available"
    }

    return release.tag_name
}

//Gets the latest release of a product from the project repository
def getLatestRelease(gitOrg, gitRepo, gitTokenId, releaseFetchMethod, gaReleaseTagRef) {
    println "[INFO] Getting latest release for:${productName}"

    if (releaseFetchMethod == "tag") {
        return getLatestReleaseByTag(gitOrg, gitRepo, gitTokenId, productName, gaReleaseTagRef)
    } else {
        return getLatestReleaseByRelease(gitOrg, gitRepo, gitTokenId, productName)
    }
}

def getLabelScore(label) {
    if (!label) {
        return 0
    }

    def score = 0
    def scores = [
            'GA': 1,
            'redhat': 1
    ]
    def parts = label.tokenize('-')

    parts.each { part ->
        if (scores.containsKey(part)) {
            score += scores[part]
        }

        if (!scores.containsKey(part) && part.isInteger()) {
            score += part.toInteger()
        }
    }

    return score
}

//checks if current semver is lower than the supposed latest one
def hasNewGARelease(currentVersion, newVersion, productName) {
    def current = ""
    def latest = ""

    if (productName == "fuse") {
        current = currentVersion.replaceAll("[^0-9/-]", "").tokenize("-")
        latest = newVersion.replaceAll("[^0-9/-]", "").tokenize("-")
    } else {
        current = currentVersion.replaceAll("[^0-9/.]", "").tokenize(".")
        latest = newVersion.replaceAll("[^0-9/.]", "").tokenize('.')
    }

    def currentMajor = current[0] as Integer
    def latestMajor = latest[0] as Integer
    def currentMinor = current[1] as Integer
    def latestMinor = latest[1] as Integer
    def currentPatch = current[2] as Integer
    def latestPatch = latest[2] as Integer
    def currentLabel = current[3]
    def latestLabel = latest[3]

    def previousVer = 0
    def currentVer = 0
    for (i = 0; i <= 2; i++) {
        if (i > 0) {
            previousVer = i - 1
        }
        currentVer = i

        def previousDiff = current[previousVer] == latest[previousVer]
        if (i == 0) {
            previousDiff = true
        }
        def currentDiff = latest[currentVer] > current[currentVer]
        if (previousDiff && currentDiff) {
            return true
        }
    }

    def currentLabelScore = getLabelScore(currentLabel)
    def latestLabelScore = getLabelScore(latestLabel)

    if (latestLabelScore > currentLabelScore) {
        return true
    }

    return false
}

//https://github.com/comquent/imperative-when
import org.jenkinsci.plugins.pipeline.modeldefinition.Utils

def when(boolean condition, body) {
    def config = [:]
    body.resolveStrategy = Closure.OWNER_FIRST
    body.delegate = config

    if (condition) {
        body()
    } else {
        Utils.markStageSkippedForConditional(STAGE_NAME)
    }
}

def ensureEvalsDir() {
    if (!fileExists("evals")) {
        sh "ln -s . evals"
    }
}

def updateManifestVariable(manifestFileTxt, name, value) {
    if (name && value) {
        println("Updating manifest variable: name = ${name}, value = ${value}")
        manifestFileTxt = manifestFileTxt.replaceFirst(/${name}: .*/, "${name}: '${value}'")
    } else {
        println("Unable to update manifest variable: name = ${name}, value = ${value}")
    }
    return manifestFileTxt
}

//Helper methods

def installationGitUrl = params.installationGitUrl ?: 'git@github.com:integr8ly/installation.git'
def installationGitRef = params.installationGitRef ?: 'master'
def githubToken = params.githubToken ?: 'jenkins-github-api-token'
def githubCredentialsID = params.credentialId ?: 'jenkinsgithub'
def releaseTagVar = params.manifestVar ?: params.releaseTagVar
def productVersionVar = params.productVersionVar
def projectOrg = params.projectOrg
def projectRepo = params.projectRepo
def productName = params.productName
def releaseFetchMethod = params.releaseFetchMethod
def productVersionLocation = params.productVersionLocation
def productVersionIdentifier = params.productVersionIdentifier
def nextBranch = params.installationProductBranch ?: "${productName}-next"
def installationManifestFile = './evals/inventories/group_vars/all/manifest.yaml'
def gaReleaseTagRef = params.gaReleaseTagRef ?: ''

currentBuild.displayName = "${currentBuild.displayName} ${productName}"

node {
    cleanWs()
    stage('Fetch Installation Repo') {
        println '[INFO] Fetch Installation Repo'
        cleanWs()
        dir('installation') {
            checkoutGitRepo(installationGitUrl, installationGitRef, githubCredentialsID)
            ensureEvalsDir()
            releaseConfig = readYaml file: installationManifestFile
        }
    }

    stage('Fetch Current Integreatly Release') {
        if (releaseTagVar) {
            componentRelease = releaseConfig[releaseTagVar]
        } else {
            componentRelease = releaseConfig[productVersionVar]
        }
        if (!componentRelease) {
            error "[ERROR] Unable to retrieve current release version!"
        }
        println "[INFO] componentRelease = ${componentRelease}"
    }

    stage('Fetch Latest GitHub Release') {
        latestRelease = getLatestRelease(projectOrg, projectRepo, githubToken, releaseFetchMethod, gaReleaseTagRef)
        if (!latestRelease) {
            error "[ERROR] Unable to retrieve latest release version!"
        }
        println "[INFO] latestRelease = ${latestRelease}"
        isGARelease = hasNewGARelease(componentRelease, latestRelease, productName)
    }

    stage('Fetch Component Product Version') {
        if (productVersionLocation && productVersionIdentifier) {
            def templateUrl = "https://raw.githubusercontent.com/${projectOrg}/${projectRepo}/${latestRelease}/${productVersionLocation}"

            if (projectOrg == "integr8ly") {
                productVersion = sh(returnStdout: true, script: "curl -i '${templateUrl}' | grep '${productVersionIdentifier}' | head -n 1 | awk '{print \$3}'")
                productVersion = productVersion.replaceAll("[\"\']v*", "")
            }

            // Current tags/releases does not have the right product version in the webapp handler.
            // This can be removed once this property has been updated with the correct information in the next release
            // https://github.com/integr8ly/tutorial-web-app-operator/blob/v0.0.4/pkg/handlers/webhandler.go#L23
            if (productName == "webapp") {
                productVersion = sh(returnStdout: true, script: "curl -i '${templateUrl}' | grep '${productVersionIdentifier}' | awk -F ':' '{print \$3}'")
                productVersion = productVersion.replaceAll("v", "")
            }

            productVersion = productVersion.trim()

            if (!productVersion) {
                error "[ERROR] Product version for ${productName} was not found. Product Version: ${productVersion}"
            }
        } else {
            productVersion = latestRelease
        }
        println "[INFO] product version: ${productVersion}"
    }

    currentBuild.description = "current: ${componentRelease}\n latest: ${latestRelease}\n productVersion: ${productVersion}\n isGARelease: ${isGARelease}"

    dir('installation') {
        sshagent([githubCredentialsID]) {
            sh 'git config --global user.name "Automatron"'
            sh 'git config --global user.email "github.eng@feedhenry.com"'

            stage('Ensure Product Next Branch') {
                gitCreateAndCheckoutBranch(nextBranch, true)
                try {
                    sh "git rebase origin/${installationGitRef}"
                } catch (Exception e) {
                    sh "git rebase --abort"
                    println "We were unable to automatically rebase the target branch '${installationGitRef}' into the source branch '${nextBranch}'. Please fix these conflicts locally and push the changes to ${nextBranch} before running this job again!"
                }
            }

            stage('Product Version Update') {
                when(isGARelease) {
                    gitCommitWhenChanges("Updated ${productName} product version to ${latestRelease}") { msgs ->
                        manifestFileTxt = readFile(installationManifestFile)
                        manifestFileTxt = updateManifestVariable(manifestFileTxt, releaseTagVar, latestRelease)
                        manifestFileTxt = updateManifestVariable(manifestFileTxt, productVersionVar, productVersion)
                        writeFile file: installationManifestFile, text: manifestFileTxt
                    }
                }
            }

            stage('Push Product Next Branch') {
                boolean doPush = nextBranch != 'master'
                if (doPush) {
                    //sh "git push --force-with-lease origin ${nextBranch}"
                    //We should be using force-with-lease, but the agents appear to have a really old git version in them.
                    sh "git push --force origin ${nextBranch}"
                }

            }
        }
    }
}
